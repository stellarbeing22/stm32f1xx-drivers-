/*
 * stm32f103xx_i2c_drivers.c
 *
 *  Created on: Oct 19, 2025
 *      Author: stellarbeing22
 */

#include "stm32f103xx_i2c_drivers.h"


/* GPIO peripheral clock */
void I2C_PeriClockControl(I2C_RegDef_t *pI2Cx, uint8_t En_or_Di)
{
	if(En_or_Di == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN;
		}else
		{
			I2C2_PCLK_EN;
		}
	}else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN;
		}else
		{
			I2C2_PCLK_EN;
		}
	}
}

/* Init and Deinit */



/* Steps to create clock (Sm)
 *
 * 1. Configure the mode in CCR, Sm/Fm (select the duty cycle using CCR 14 in Fm)
 * 2. Program the FREQ field in CR2 with value of Pclk1 (8MHz default, HSi,F1)
 * 3. Calculate the value of CCR using the subtable formula and fill the bitfield
 *    inside the CCR of CCR Reg
 *
 *    for Sm:
 *    	Thigh = CCR * T PCLK1
 *    	Tlow = CCR * TPCLK1
 *
 *    for Fm:
 *    	If DUTY = 0:
 *    		Thigh = CCR * T PCLK1
 *    		Tlow = 2 * CCR * TPCLK1
 *    	If DUTY = 1:
 *    		Thigh = 9 * CCR * TPCLK1
 *    		Tlow = 16 * CCR * TPCLK1
 *
 *   for example, lets say PCLK1 = 8MHz (TPCLK = 125nS) and we need 100KHz (Sm) on SCL
 *   CCR[15] <- Sm
 *   FREQ[5:0] <- 8
 *   now calculate CCR
 *
 *   for 100KHz, Sm, Thigh = Tlow = 5 uS
 *
 *   thus 5 uS = CCR * 125 nS
 *   => CCR= 40
 *
 *  # For Sm: Tlow ~ Thigh
 *  # For Fm: Tlow = 2Thigh or 1.8Thigh
 *
 *
 *  Clock streaching
 *  The holding of the clock to the ground (0) level
 *
 *  The moment the clock is held at low, the whole I2C
 *  interface pauses until clock is given its optimal operation level
 * */
void I2C_init(I2C_Handler_t *pI2CHandle)
{
	uint32_t tempReg = 0;

	//1. Enable peripheral Clock
	I2C_PeriClockControl(pI2CHandle->pI2Cx, ENABLE);
	//2. Enable ACK control
	tempReg |= pI2CHandle->I2C_Config.I2C_ACKControl << I2C_CR1_ACK;
	//set FREQ[5:0]


}

void I2C_Deinit(SPI_RegDef_t *pSPIx)
{}


/* IQR config and ISR handling */
void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t En_or_Di)
{}

void I2C_IRQPriorityConfig(uint8_t IRQNumber,uint32_t IRQPriority)
{}

/* Other Peripheral Control APIs */
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx, uint32_t FlagName)
{}

void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t En_Or_Di)
{
	if(En_Or_Di == ENABLE)
	{
		pI2Cx->CR1 |= (1<<I2C_CR1_PE);
	}else
	{
		pI2Cx->CR1 &= ~(1<<I2C_CR1_PE);
	}
}

/*Application event*/
 void I2C_ApplicationEventCallback(I2C_Handler_t *pI2CHandle,uint8_t AppEve)
 {}

 uint32_t RCC_getPCLK1value()
 {
	 //pclk1 -> the cock of the APB1 bus (max 32MHz), sysclk is the system clock;
	 uint32_t pclk1,sysclk;

	 //clksrc is the sourse of the clock =(HSI, HSE, PLL), AHB_Prescaler,
	 //APB1_Prescaler are the prescaler values, HPRE_Value is the clock div(AHB)
	 //and PPRE1_Value is the clock div(APB1)
	 uint8_t clksrc, AHB_Prescaler,APB1_Prescaler, HPRE_Value, PPRE1_Value;

	 //the array name says it all, the prescalers for AHB bus and APB1 bus
	 uint8_t AHB_Prescaler[8] = {2,4,8,16,32,64,128,256};
	 uint8_t APB1_Prescaler[4] = {2,4,8,16};

	 clksrc = ((RCC->CFGR >> 2)&0x3);
	 if(clksrc == 0)
	 {
		 sysclk = 8000000;
	 }else if(clksrc == 1)
	 {
		 sysclk = 8000000;
	 }else if(clksrc == 2)
	 {
		 sysclk = RCC_getPLLOutputClk();
	 }

	 HPRE_Value = ((RCC->CFGR >> 4)&0xF);
	 if(HPRE_Value < 8)
	 {
		 AHB_prescaler = 1;
	 }else
	 {
		 AHB_Prescaler = AHB_Prescaler[HPRE-8];
	 }

	 PPRE1_Value = ((RCC->CFGR >> 8)&0x3);


	 return pclk1;
 }

uint32_t RCC_getPLLOutputClk()
{}
